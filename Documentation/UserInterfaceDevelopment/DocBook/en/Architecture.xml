<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>Architecture</title>

  <para>In this chapter, the basic architecture of the user interface is
  explained.</para>

  <para>We have some key design goals we followed while creating this
  architecture:</para>

  <itemizedlist>
    <listitem>
      <para><emphasis>Extensibility:</emphasis> TYPO3 is famous for its
      extensibility, and this of course should also apply to the TYPO3 Phoenix
      User Interface. In this chapter, the basic extensibility principles are
      explained.</para>
    </listitem>

    <listitem>
      <para><emphasis>Loading Order Independence:</emphasis> Often, big
      JavaScript applications are very fragile, or even break, because of
      wrong inclusion order of their JavaScript files. Because our system is
      highly extensible, much work has been done to make sure the whole system
      has only very small loading order dependencies, i.e. for most files, the
      loading order is completely irrelevant, but still providing predictable
      results.</para>
    </listitem>
  </itemizedlist>

  <section>
    <title>JavaScript Modules</title>

    <para>All JavaScript is encapsulated in so-called
    <emphasis>modules</emphasis>, which are packages of (JavaScript)
    functionality. Modules are built in a way such that if you add or remove a
    module, there will be no JavaScript errors (if the module itself does not
    contain syntax errors of course).</para>

    <para>The base directory where all built-in TYPO3 Backend modules are
    located is in <filename>TYPO3/Public/Backend/JavaScript</filename>.</para>

    <para>Each module has a <emphasis>Module Descriptor</emphasis> file (TODO:
    Name?) which is named
    <filename><replaceable>Modulename</replaceable>Module.js</filename>, i.e.
    the module descriptor for the <emphasis>Content</emphasis> module can be
    found inside <filename>Content/ContentModule.js</filename>. The Module
    Descriptor is a <emphasis>singleton</emphasis> and also acts as an
    <emphasis>event bridge</emphasis> for the module.</para>

    <para>Every module descriptor can have the following two methods:</para>

    <itemizedlist>
      <listitem>
        <para><methodname>configure(TYPO3.TYPO3.Core.Registry)</methodname>: this
        method should do all changes to the central registry (which gets
        passed as argument) inside this method. See the sectioon on the
        Registry for more explanation what it does. Essentially, the registry
        is just an extensible JSON structure which is used at many places to
        configure the TYPO3 Backend User Interface.</para>
      </listitem>

      <listitem>
        <para><methodname>initialize(TYPO3.TYPO3.Core.Application)</methodname>:
        in this method, the module descriptor can register itself to be called
        after another dependent module has been initialized, using the
        <code>application.afterInitializationOf(<replaceable>moduleName</replaceable>,
        <replaceable>callback</replaceable>,
        <replaceable>scope</replaceable>)</code> method.</para>
      </listitem>

      <listitem>
        <para>Additionally, the module descriptor exposes the public API of
        this module.</para>
      </listitem>

      <listitem>
        <para>And, of course it can also have private methods used to
        structure the code.</para>
      </listitem>
    </itemizedlist>

    <para>Let's look at an example for a module descriptor:</para>

    <example>
      <title>Example Module Descriptor</title>

      <programlisting>Ext.ns("Acme.TYPO3.Dummy");

TYPO3.TYPO3.Core.Application.createModule('Acme.TYPO3.Dummy.DummyModule', {

	configure: function(registry) {
		registry.append('menu[main]', 'report', {<co
          xml:id="example-module-descriptor.1" />
			title: 'Report',
			itemId: 'report'
		});
	},

	initialize: function(application) {
		application.afterInitializationOf('TYPO3.TYPO3.UserInterface.UserInterfaceModule', function(userInterfaceModule) {<co
          xml:id="example-module-descriptor.2" />

			userInterfaceModule.addContentArea('report', 'dummy', {<co
          xml:id="example-module-descriptor.3" />
				xtype: 'Acme.TYPO3.Dummy.DummyContentArea',
				name: 'Report'
			});
			userInterfaceModule.contentAreaOn('menu[main]/report', 'report', 'dummy');<co
          xml:id="example-module-descriptor.4" />
	}
});</programlisting>

      <calloutlist>
        <callout arearefs="example-module-descriptor.1">
          <para>Inside the <methodname>configure</methodname> method, a new
          module called <emphasis>report</emphasis> is being added to the
          registry.</para>
        </callout>

        <callout arearefs="example-module-descriptor.2">
          <para>The <code>DummyModule</code> needs the
          <code>UserInterfaceModule</code> to work correctly; that's why it
          expresses a dependency inside the
          <methodname>initialize</methodname> method, using the
          <code>application.afterInitializationOf(...)</code> method. The
          specified callback function is only executed if the
          <code>UserInterfaceModule</code> is present and has been
          loaded.</para>
        </callout>

        <callout arearefs="example-module-descriptor.3">
          <para>Now follows the other module's specific initialization code.
          The <package>UserInterfaceModule</package> has a method
          <code>addContentArea(<replaceable>mainTabName</replaceable>,
          <replaceable>name</replaceable>,
          <replaceable>configuration</replaceable>)</code> which adds a new
          content area to the specified main tab name.</para>
        </callout>

        <callout arearefs="example-module-descriptor.4">
          <para>The <package>UserInterfaceModule</package> has another method
          <methodname>contentAreaOn(<replaceable>nameOfActivatedElement</replaceable>,
          <replaceable>mainTabName</replaceable>,
          <replaceable>name</replaceable>)</methodname>, which is used to show
          the content area if a certain element, specified through the first
          parameter, is activated.</para>
        </callout>
      </calloutlist>
    </example>

    <para>TODO: Separate Core from the rest, and move to other package!</para>

    <para>TODO: add doc comments to example module descriptor</para>
  </section>

  <section>
    <title>The Registry</title>

    <para>The TYPO3 backend is mainly extensible because of a central
    component which stores how the User Interface is built together: the
    <emphasis>registry</emphasis>. This is a singleton object available inside
    <classname>TYPO3.TYPO3.Core.Registry</classname>, and is thus accessible in
    all components.</para>

    <para><emphasis>The Registry is an extensible JSON
    structure.</emphasis></para>

    <para>It works in two steps: First, all modules can add / change things
    inside the registry inside the <methodname>configure</methodname> method
    of their Module Descriptor. After that, the registry is
    <emphasis>compiled</emphasis>, and after that, is just a regular JSON
    structure. Let's follow an example what the registry does, so you can gain
    an intuitive understanding of it:</para>

    <programlisting>// Inside a Module Descriptor
configure: function(registry) {
	registry.set('some/path/foo', {title: 'Hello'});
	// this is the same as:
	registry.set('some/path/foo/title', 'Hello');
}
// after the registry is compiled, it looks like:
{ some: { path: {foo: {title: 'Hello'}}}}</programlisting>

    <para>So far, this is what you would expect. Now follows an example which
    shows the interaction between multiple modules:</para>

    <programlisting>// Inside a Module Descriptor
configure: function(registry) {
	registry.set('some/path/foo/title', 'World'<emphasis>, 10</emphasis>);
}
// Inside another module descriptor:
configure: function(registry) {
	registry.set('some/path/foo', {title: 'Hello'});
}

// after the registry is compiled, it looks like:
{ some: { path: {foo: {title: 'World'}}}}</programlisting>

    <para>If two modules try to set the same key, somehow it has to be
    determined which value "wins" -- and as we do not want to depend on the
    loading order, we have added the concept of
    <emphasis>priorities</emphasis> to the registry. In the above example, you
    see that in the result, the string <code>World</code> is displayed because
    it has a priority of 10, and the other call to set the same key has no
    priority set (which defaults to a priority value of zero). If the two
    <code>registry.set</code> calls were executed in a different order, the
    result after the compilation would still be the same. So,
    <emphasis>priorities make sure the registry behaves
    deterministically</emphasis>.</para>

    <para>Let's say we want to remove an element from the registry -- for
    that, there is the <code>registry.remove</code> call:</para>

    <programlisting>// Inside a Module Descriptor
configure: function(registry) {
	registry.remove('some/path/foo/description', 'foo');
}
// Inside another module descriptor:
configure: function(registry) {
	registry.set('some/path/foo', {
		title: 'Hello',
		description: ' This is a long description'
	});
}

// after the registry is compiled, it looks like:
{ some: { path: {foo: {title: 'Hello'}}}}</programlisting>

    <para>What happened here? Although the element is removed before it is
    actually inserted, the result is still what one would expect. If you look
    closely, you will notice that we did <emphasis>not</emphasis> specify a
    priority for <code>registry.remove</code> -- and still the result is what
    we want. The reason is that the registry processes all operations in a
    strictly defined order -- and the <code>delete</code> operation is
    processed after all other operations. For a single operation, the
    priorities are then used to determine the processing order.</para>

    <note>
      <para>All registry operations can deal with priorities, but we left them
      out to not complicate the examples below.</para>
    </note>

    <para>So far, you have seen how to build JSON objects with the registry --
    and now we will look at creating arrays with the registry. In the next
    example, you will see a simple invocation of the
    <code>registry.append</code> method.</para>

    <programlisting>// Inside a Module Descriptor
configure: function(registry) {
	registry.append('menu/main', 'edit', {title: 'Edit the element'});
}
// after the registry is compiled, it looks like:
{
	menu: {
		main: [
			{
				title: 'Edit the element',
				key: edit
			}
		]
	}
}</programlisting>

    <para>So, what happened now? Because we used <code>append</code>, the
    registry assumes that <code>menu/main</code> is an
    <emphasis>array</emphasis>, and no object anymore. The second argument of
    <code>append</code> is an <emphasis>array key</emphasis>, which can be
    used to reference this array element later inside a path.</para>

    <para>When you look at the result, you will see that menu/main is really
    an array now, and the array element is again an object with the title we
    specified. Additionally, the array element gets the array key inserted
    under the special name <code>key</code>. Let's look how this array key can
    be used to modify objects:</para>

    <programlisting>// Inside a Module Descriptor
configure: function(registry) {
	registry.append('menu/main', 'edit', {title: 'Edit the element'});
}
// Inside another module descriptor:
configure: function(registry) {
	registry.set('menu/main/edit/title', 'Element bearbeiten');
}

// after the registry is compiled, it looks like:
{
	menu: {
		main: [
			{
				title: 'Element bearbeiten',
				key: edit
			}
		]
	}
}</programlisting>

    <para>Here, you see that <code>set</code> is used to change the title of
    the <code>edit</code> element inside the array (again, the order of the
    registry statements does not matter).</para>

    <note>
      <para>There is also a <code>prepend</code> method which inserts an
      element at the beginning of an array, and not at the end like
      <code>append</code>.</para>
    </note>

    <para>Often, one does not want to insert an element at the end or at the
    beginning of an array, but somewhere before or after an element. The
    registry supports the two operations <code>insertAfter</code> and
    <code>insertBefore</code> for exactly that: To insert a sibling of a given
    node. Let's look at an example:</para>

    <programlisting>// Inside a Module Descriptor
configure: function(registry) {
	registry.insertAfter('menu/main/edit', 'preview', {title: 'Preview'});
}
// Inside another module descriptor:
configure: function(registry) {
	this.registry.append('menu/main', 'edit', {title: 'Edit'});
	this.registry.append('menu/main', 'delete', {title: 'Delete'}, 10);
}

// after the registry is compiled, it looks like:
{
	menu: {
		main: [{
			title: 'Edit',
			key: 'edit'
		}, {
			title: 'Preview',
			key: 'preview'
		}, {
			title: 'Delete',
			key: 'delete'
		}]
	}
}</programlisting>

    <para>Here, you see that "preview" has been inserted after "edit".</para>

    <section>
      <title>Logical objects and the "children" property</title>

      <para>If one looks at JSON objects which form a tree structure, they
      often look like the following:</para>

      <programlisting>{
	menu: {
		title: 'Home',
		children: [
			{
				key: 'company',
				title: 'Our Company',
				children: [
					{
						key: 'partners',
						title: 'Partners'
					}
				]
			}, {
				id: ...,
				title: ...
			}
		]
	}
}</programlisting>

      <para>So basically, an object which has children often stores these in
      the special property <code>children</code>. Now, let's imagine we want
      to add a new child to <code>company</code> using the registry, then this
      is possible with <code>registry.append('menu/children/company/children',
      'investor-relations', {title: 'Investor Relations'})</code>. However,
      this is quite unreadable because of the many
      <code>.../children/...</code> sections in the path. For that, we
      invented a little syntactic sugar, so you can re-write
      <code>menu/children/company/children</code> as
      <code>menu[]/company[]</code>, which is a lot more readable.</para>

      <para>Now imagine we would rename the <code>children</code> property to
      <code>childNodes</code> -- in this case, instead of writing
      <code>menu/childNodes/company/childNodes</code>, one could write
      <code>menu[childNodes]/company[childNodes]</code>. Although this is
      semantically equivalent, it is better readable because it says: "I want
      to go to the <code>childNodes</code> property of the <code>menu</code>
      object, and from there I want to go to the <code>childNodes</code>
      property of the <code>company</code> object."</para>

      <para>So, if you go to a real sub-object, use the slash as delimiter,
      but if you just traverse into a more complex object, use the
      bracket-syntax.</para>
    </section>

    <section>
      <title>special paths in the registry</title>

      <para>TODO: maybe this should be moved somewhere else, later.</para>

      <para>This section explains the basic layout and structure of the
      registry.</para>

      <itemizedlist>
        <listitem>
          <para><code>menu</code>: Contains all menu definitions</para>

          <itemizedlist>
            <listitem>
              <para><code>main</code>: Contains the main menu displayed in the
              top area of the Backend</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><code>schema/<replaceable>ContentType</replaceable></code>:
          schema definition for the content type</para>

          <itemizedlist>
            <listitem>
              <para><code>service</code>: describes the endpoints which should
              be used for showing, updating, ceating and deleting data.</para>
            </listitem>

            <listitem>
              <para><code>properties</code>: describes for each property its
              type and the validations which apply.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><code>form</code>: Configuration for forms</para>

          <itemizedlist>
            <listitem>
              <para><code>type/<replaceable>ContentType</replaceable></code>:
              Form definitions for the given content type</para>

              <itemizedlist>
                <listitem>
                  <para><code>standard</code>: standard form definition which
                  is used by default</para>
                </listitem>

                <listitem>
                  <para>There might be additional form definitions for
                  specific places in the backend.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><code>editor/<replaceable>Type</replaceable></code>:
              Editor configuration for the given type.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Events</title>

    <para>The different components of the user interface communicate via
    events. A module fires some events, and other modules listen to these
    events and do some specific actions.</para>

    <para>Every Module Descriptor inherits from
    <classname>Ext.util.Observable</classname>, so there can be events thrown
    on these objects, and one can listen to these events. Here is a quick
    example how that works, which should be familiar to everybody knowing
    <classname>Ext.util.Observable</classname>:</para>

    <programlisting>// Register an event listener
TYPO3.TYPO3.Core.Application.on('logout', this._onLogout, this);

// at some other place, the event is fired, which triggers all registered event listeners:
TYPO3.TYPO3.Core.Application.fireEvent('logout');</programlisting>

    <para>Some events are only relevant to the internals of the module, and
    should not be exposed to other modules. These events should, by
    convention, start with an underscore character, and in their documentation
    block, have the <code>@private</code> annotation.</para>

    <para>TODO: should we add some section about sub-namespaces inside event
    names?</para>
  </section>

  <section>
    <title>Forms</title>

    <para></para>
  </section>

  <section>
    <title>Exception Handling</title>

    <para></para>
  </section>

  <section>
    <title>Custom widgets explained</title>

    <para>-&gt; extra chapter</para>

    <section>
      <title>BreadcrumbMenu</title>

      <para></para>
    </section>

    <section>
      <title></title>

      <para></para>
    </section>
  </section>
</chapter>
